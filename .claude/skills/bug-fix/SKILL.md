---
name: bug-fix
description: 不具合修正を確実に行うスキル。理解→仮説→修正計画→実装→静的検証→動的検証のフローで、原因特定から修正完了まで追跡。「バグ修正して」「不具合を直して」などの指示で起動。
---

# Bug Fix

不具合修正を「なんとなく直った」ではなく「確実に直った」と言える状態にするためのスキルです。

---

## なぜこのスキルが必要か

不具合修正でよくある失敗パターン：

- コードの前提や影響範囲を理解せずに修正してしまう
- テストを通すためだけに安易なモックを追加してしまう
- 修正後のインポートエラーや型エラーを見落とす
- 修正した関数の呼び出し元への影響を確認しない

このスキルは、これらの失敗を防ぐためのフローを提供します。

---

## フロー概要

```
┌─────────────────────────────────────────────────────────────┐
│  フェーズ1: 理解                                             │
│  ├── 不具合の詳細を確認（再現手順、期待動作、実際動作）      │
│  ├── 関連コードを調査                                        │
│  └── 影響範囲を特定                                          │
└─────────────────────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│  フェーズ2: 仮説                                             │
│  ├── 原因の仮説を立てる                                      │
│  └── 仮説を検証                                              │
└─────────────────────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│  フェーズ3: 修正計画                                         │
│  ├── 修正箇所と方法を明確化                                  │
│  ├── リスクを説明                                            │
│  └── ユーザーの承認を得る ⚠️ 必須                            │
└─────────────────────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│  フェーズ4: 実装                                             │
│  └── 最小限の変更で修正                                      │
└─────────────────────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│  フェーズ5: 静的検証                                         │
│  ├── インポートエラー確認                                    │
│  ├── 型の整合性確認                                          │
│  └── 呼び出し元への影響確認                                  │
└─────────────────────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────┐
│  フェーズ6: 動的検証                                         │
│  ├── 元の不具合が再現しないことを確認                        │
│  └── 関連機能への悪影響がないことを確認                      │
└─────────────────────────────────────────────────────────────┘
```

---

## フェーズ詳細

### フェーズ1: 理解

**目的**: 不具合と関連コードを深く理解する

**やること**:
1. ユーザーから不具合の詳細を確認
   - 再現手順
   - 期待される動作
   - 実際の動作
   - エラーメッセージ（あれば）
2. 関連コードを調査
   - 問題が発生している箇所を特定
   - その箇所が依存しているコード・ライブラリを確認
   - その箇所を呼び出している箇所を確認
3. 影響範囲を特定
   - 修正が影響する可能性のあるファイル・関数をリストアップ

**成果物**: 不具合の理解と影響範囲のまとめをユーザーに報告

---

### フェーズ2: 仮説

**目的**: 根本原因を特定する

**やること**:
1. 不具合の原因について仮説を立てる
2. 仮説を検証する方法を決める
3. 必要に応じてデバッグ出力やログを確認

**成果物**: 原因の仮説と検証結果をユーザーに報告

---

### フェーズ3: 修正計画

**目的**: 修正方針をユーザーに提示し承認を得る

**やること**:
1. 修正箇所と修正方法を明確にする
2. 修正に伴うリスクを説明
3. 代替案があれば提示
4. ユーザーの承認を得る

**成果物**: 修正計画書（修正箇所、方法、リスク）

**重要**: ユーザーの承認なしに実装に進まない

---

### フェーズ4: 実装

**目的**: 最小限の変更で修正を行う

**やること**:
1. 承認された計画に従って修正を実装
2. 修正は最小限に留める（関係ないリファクタリングはしない）
3. 変更したファイルと行をリストアップ

**成果物**: 修正コード

---

### フェーズ5: 静的検証

**目的**: コードベースの整合性を確認する

**チェックリスト**:

| チェック項目 | 確認方法 |
|-------------|----------|
| インポートエラー | 修正ファイルと依存ファイルのimport文を確認 |
| 型の整合性 | 関数シグネチャ、戻り値、引数の型が一致しているか |
| 依存関係の破損 | 修正した関数/クラスを呼び出している箇所を確認 |
| ロジックの一貫性 | 修正がビジネスロジック全体と矛盾していないか |
| 未使用コード | 修正により不要になったコードが残っていないか |
| リンター/フォーマッター | プロジェクトのルールに準拠しているか |

**やること**:
1. 修正したファイルのインポートが正しいか確認
2. 修正した関数/クラスの呼び出し元をすべてGrepで検索
3. 呼び出し元のコードを読み、引数・戻り値の使い方に問題がないか確認
4. `pnpm lint` を実行
5. 問題があれば修正し、再度確認

**成果物**: 静的検証結果の報告（問題なし or 修正内容）

---

### フェーズ6: 動的検証

**目的**: 本番に近い形で動作確認する

**原則**:
- モックは外部APIの書き込み系など、本当に必要な箇所のみ
- 読み取り系は可能な限り本番コードを使用
- テストケースは「元の不具合が再現しないこと」を最優先

**やること**:
1. 元の不具合が再現しないことを確認
2. 関連する既存テストがあれば実行（`pnpm test:run`）
3. 影響範囲の機能が正常に動作することを確認
4. 必要に応じて新規テストを追加

**テスト方針**:

| 対象 | 方針 |
|------|------|
| Server Actions | 本番コードをそのまま呼び出し |
| コンポーネント | Testing Library で実際のレンダリング |
| データベース | テスト用DBまたはモック |
| 外部API | 読み取りは本番、書き込みのみモック |

**成果物**: 動的検証結果の報告

---

## アンチパターン（やってはいけないこと）

以下の行動は厳禁です：

| アンチパターン | なぜダメか |
|---------------|-----------|
| 原因を理解せずにコード変更 | 別の問題を引き起こす可能性が高い |
| テストを通すためだけのモック追加 | 本番では動かない「偽の成功」になる |
| 影響範囲を確認せずに修正完了とする | 呼び出し元で新たな不具合が発生する |
| インポートや型エラーを無視して次に進む | 実行時エラーの原因になる |
| 修正した関数の呼び出し元を確認しない | 引数や戻り値の変更が伝播しない |
| 承認前に実装を進める | 手戻りが発生する |
| 関係ないリファクタリングを同時に行う | 修正範囲が不明確になり検証が困難に |

---

## 完了条件

以下をすべて満たした場合のみ、修正完了とする：

- [ ] 原因を特定し、ユーザーに説明した
- [ ] 修正計画をユーザーが承認した
- [ ] 静的検証（インポート、型、呼び出し元）をすべてパスした
- [ ] 動的検証（元の不具合が再現しないこと）を確認した
- [ ] 関連機能への悪影響がないことを確認した

---

## 使用例

```
ユーザー: 「ログイン後にリダイレクトされない不具合がある」

Claude:
1. [フェーズ1: 理解]
   - 再現手順を確認
   - Login.tsx と middleware.ts を調査
   - 影響範囲: 認証フロー全体

2. [フェーズ2: 仮説]
   - 仮説: signIn.email の戻り値チェックが不足
   - 検証: レスポンスをログ出力して確認

3. [フェーズ3: 修正計画]
   - 修正箇所: Login.tsx の handleSubmit
   - 修正方法: result.error チェック後に router.push を追加
   - リスク: なし
   → ユーザーに確認「この方針でよいですか？」

4. [フェーズ4: 実装]
   - Login.tsx を修正

5. [フェーズ5: 静的検証]
   - インポート: OK
   - 型: OK
   - 呼び出し元: page.tsx（影響なし）
   - lint: OK

6. [フェーズ6: 動的検証]
   - ログイン→リダイレクト確認: OK
   - ログアウト後の再ログイン: OK
   → 修正完了
```
